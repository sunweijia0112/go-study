### 变量声明

```text
var 变量名字 类型 = 表达式
```

- “类型”或“= 表达式”两个部分可以省略其中的一个
- 如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息
- 如果初始化表达式被省略，那么将用零值初始化该变量
- 数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil
- 数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值

### 声明并初始化一组变量

```text
var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string
var f, err = os.Open(name)      // os.Open returns a file and an error

```

### 变量初始化时间点

- 在包级别声明的变量会在main入口函数执行前完成初始化
- 局部变量将在声明语句被执行到的时候完成初始化


### 简短变量声明
- 简短变量声明被广泛用于大部分的局部变量的声明和初始化
- var形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方


```text
名字 := 表达式  // 变量的类型根据表达式来自动推导
```

```text
anim := gif.GIF{LoopCount: nframes}
freq := rand.Float64() * 3.0
t := 0.0
```


简短变量声明语句也可以用来声明和初始化一组变量,但是这种同时声明多个变量的方式应该限制只在可以提高代码可读性的地方使用，比如for语句的循环的初始化语句部分。

```text
i, j := 0, 1
```

简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了，如下代码所示

```text
in, err := os.Open(infile)
// ...
out, err := os.Create(outfile)
```

简短变量声明语句中必须至少要声明一个新的变量
```text
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) // compile error: no new variables
```


### 指针变量

- 一个变量对应一个保存了变量对应类型值的内存空间
- 一个指针的值是另一个变量的地址

```text
x := 1
p := &x         // p, of type *int, points to x
fmt.Println(*p) // "1"
*p = 2          // equivalent to x = 2
fmt.Println(x)  // "2"
```

- 对于聚合类型每个成员——比如结构体的每个字段、或者是数组的每个元素——也都是对应一个变量，因此可以被取地址
- 变量有时候被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受&取地址操作
- 任何类型的指针的零值都是nil。如果p指向某个有效变量，那么p != nil测试为真

```text
// 通过指针来更新变量的值，然后返回更新后的值
func incr(p *int) int {
    *p++ // 非常重要：只是增加p指向的变量的值，并不改变p指针！！！
    return *p
}

v := 1
incr(&v)              // side effect: v is now 2
fmt.Println(incr(&v)) // "3" (and v is 3)
```

### new函数
调用内建的new函数也可以创建变量，表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的0值，然后返回变量地址，返回的类型为*T

```text
p := new(int)   // p, *int 类型, 指向匿名的 int 变量
fmt.Println(*p) // "0"
*p = 2          // 设置 int 匿名变量的值为 2
fmt.Println(*p) // "2"
```

new函数类似是一种语法糖

```text
func newInt() *int {
    return new(int)
}

func newInt() *int {
    var dummy int
    return &dummy
}

```

每次调用new函数都返回一个新的变量地址

### 变量的生命周期

- 对于包一级的变量，变量的生命周期和整个程序的运行周期是一致的
- 局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止

那么Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？

> 基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果

因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在
